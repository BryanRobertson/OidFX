//======================================================================================
//! @file         TextureUnit.h
//! @brief        Class representing the state for a single texture unit
//!               
//!               
//!               
//! @author       Bryan Robertson
//! @date         Wednesday, 29 June 2005
//! @copyright    Bryan Robertson 2005
//
//				  This file is part of OidFX Engine.
//
//  			  OidFX Engine is free software; you can redistribute it and/or modify
//  			  it under the terms of the GNU General Public License as published by
//  			  the Free Software Foundation; either version 2 of the License, or
//  			  (at your option) any later version.
//
//  			  OidFX Engine is distributed in the hope that it will be useful,
//  			  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  			  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  			  GNU General Public License for more details.
//
//  			  You should have received a copy of the GNU General Public License
//  			  along with OidFX Engine; if not, write to the Free Software
//  			  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//
//======================================================================================


#include <iostream>
#include <deque>
#include "Math/Vector3D.h"
#include "Math/Matrix4x4.h"
#include "Renderer/Colour4f.h"
#include "Renderer/RendererStateConstants.h"
#include "Renderer/Texture.h"
#include "Renderer/Material.h"


#ifndef RENDERER_TEXTUREUNIT_H
#define RENDERER_TEXTUREUNIT_H


//=========================================================================
// Forward declaration
//=========================================================================
namespace Renderer { class IRenderer; class TextureUnit; class TexturePrecacheList; }



//namespace Renderer
namespace Renderer
{

	//=========================================================================
    // Types
    //=========================================================================
	enum EXFormType 
	{ 
		XFORM_SCROLL_X, 
		XFORM_SCROLL_Y, 
		XFORM_ROTATE,
		XFORM_SCALE_X,
		XFORM_SCALE_Y
	};

	enum EWaveType
	{
		WAVE_SINE,
		WAVE_TRIANGLE,
		WAVE_SQUARE,
		WAVE_SAWTOOTH,
		WAVE_INVERSE_SAWTOOTH
	};

	struct TextureBlendOp
	{
		ETextureOp			   operation;
		ETextureArgument	   arg1;
		ETextureArgument	   arg2;
	};



	//!@class	TextureUnit
	//!@brief	Class representing the state for a single texture unit
	class TextureUnit
	{
		public:

			TextureUnit ( );

			
			//=========================================================================
            // Public types
            //=========================================================================
			struct WaveXForm
			{
				EXFormType transformType;
				EWaveType  waveType;
				Float	   base;
				Float	   frequency;
				Float	   phase;
				Float	   amplitude;
			};


			//=========================================================================
			// Friends
			//=========================================================================
			friend std::ostream& operator << ( std::ostream& out, const Renderer::TextureUnit& textureUnit );


            //=========================================================================
            // Public methods
            //=========================================================================

			void UpdateTextureAnimations ( Float timeElapsedInSeconds );
			void Precache ( TexturePrecacheList& precacheList );
			void UpdateTextureMatrix ( Math::Matrix4x4& matrix ) const;

			friend bool operator < ( const TextureUnit& lhs, const TextureUnit & rhs );

            //=========================================================================
            // Public mutator methods
            //=========================================================================

			//
			void SetHandle ( HTexture handle )					{ m_textureHandle = handle;	}
			void SetName ( const Char* name )					{ m_name = name; m_nameHash = Core::GenerateHashFromString ( m_name.c_str() );  }
			void SetType ( ETextureType type )					{ m_type = type;					}
			void SetAutoGenerated ( bool autoGenerated )		{ m_autoGenerated = autoGenerated;  }

			//Filtering
			void SetMinFilter ( ETextureFilter filter )	throw()	{ m_minFilter = filter;		}
			void SetMagFilter ( ETextureFilter filter )	throw()	{ m_magFilter = filter;		}
			void SetMipFilter ( ETextureFilter filter )	throw()	{ m_mipFilter = filter;		}
			void SetMaxAnisotropy ( UInt maxAnisotropy ) throw() { m_maxAnisotropy = maxAnisotropy;	}

			//Multitexture blending
			inline void SetColourOp ( ETextureOp operation, ETextureArgument arg1, ETextureArgument arg2 ) throw();
			inline void SetAlphaOp  ( ETextureOp operation, ETextureArgument arg1, ETextureArgument arg2 ) throw();

			inline void SetConstantColour ( const Colour4f& colour ) throw() { m_constantColour = colour; }

			//Texture coordinate related
			inline void SetAddressingMode ( ETextureAddressModeType type, ETextureAddressingMode addressingMode ) throw();

			void SetCoordinateSet ( ETextureCoordSetID coordinateSet ) throw()		 { m_coordinateSet = coordinateSet; }
			void SetCoordinateGenMode ( ETextureCoordGen texGenMode ) throw()		 { m_texCoordGenerationMode = texGenMode; }
			
			//Static texture transformations
			void SetScroll ( const Math::Vector3D& scroll ) throw()	{ m_scroll = scroll;	}
			void SetScale  ( const Math::Vector3D& scale ) throw()	{ m_scale = scale;		}
			void SetRotate ( Float rotation ) throw()				{ m_rotate = rotation;	}

			//Basic animated texture transformations
			void SetScrollAnim ( const Math::Vector3D& scrollAnim ) throw() { m_scrollAnim = scrollAnim; }
			void SetScaleAnim  ( const Math::Vector3D& scale ) throw()		{ m_scaleAnim = scale;		 }
			void SetRotateAnim ( Float rotation ) throw()					{ m_rotateAnim = rotation;   }

			inline void AddWaveTransform ( EXFormType transformType, EWaveType waveType, Float base,
											Float frequency, Float phase, Float amplitude  ) throw();


            //=========================================================================
            // Public accessor methods
            //=========================================================================

			const std::string&  Name() const throw()				{ return m_name;			}
			UInt				NameHash() const throw()			{ return m_nameHash;		}
			bool				AutoGenerated() const throw()		{ return m_autoGenerated;	}
			HTexture			TextureHandle() const throw()		{ return m_textureHandle;	}
			ETextureType		TextureType() const throw()			{ return m_type;			}

			//Filtering
			ETextureFilter MinFilter () const throw()	{ return m_minFilter;	}
			ETextureFilter MagFilter () const throw()	{ return m_magFilter;	}
			ETextureFilter MipFilter () const throw()	{ return m_mipFilter;	}
			UInt		   MaxAnisotropy () const throw() { return m_maxAnisotropy; }

			//Multitexture blending
			const TextureBlendOp& ColourOp () const throw()	{ return m_colourOp;  }
			const TextureBlendOp& AlphaOp () const throw()	{ return m_alphaOp;	  }

			const Colour4f&	ConstantColour() const throw()	{ return m_constantColour;	}

			//Texture coordinate related
			inline ETextureAddressingMode	AddressingMode(ETextureAddressModeType type) const throw();
			
			ETextureCoordSetID		CoordinateSet() const throw()		{ return static_cast<ETextureCoordSetID>(m_coordinateSet); }
			ETextureCoordGen		CoordinateGenMode() const throw()	{ return m_texCoordGenerationMode;	}
			
			//Static texture transformations
			const Math::Vector3D&	Scroll() const throw()		{ return m_scroll;	}
			const Math::Vector3D&	Scale() const throw()		{ return m_scale;	}
			Float					Rotate() const 	throw()		{ return m_rotate;	}

			const Math::Vector3D& ScrollAnim() const	{ return m_scrollAnim;	}
			const Math::Vector3D& ScaleAnim() const		{ return m_scaleAnim;	}
			Float				  RotateAnim() const	{ return m_rotateAnim;	}

			UInt WaveTransformCount() const	throw()		{ return m_waveTransforms.size();	}
			
			inline const WaveXForm& GetWaveTransform ( UInt index ) const throw();

			inline const Math::Matrix4x4& GetTextureMatrix() const		{ return m_textureTransform;	}

		private:


            //=========================================================================
            // Private methods
            //=========================================================================
			std::string  m_name;
			UInt		 m_nameHash;
			bool		 m_autoGenerated;
			HTexture	 m_textureHandle;
			ETextureType m_type;

			//Texture filtering
			ETextureFilter		   m_minFilter;
			ETextureFilter		   m_magFilter;
			ETextureFilter		   m_mipFilter;
			UInt				   m_maxAnisotropy;
			
			//Multitexture blending
			TextureBlendOp		   m_colourOp;	
			TextureBlendOp		   m_alphaOp;
			Colour4f			   m_constantColour;

			//Texture coordinate related
			UInt					m_coordinateSet;
			ETextureAddressingMode  m_addressingModeU;
			ETextureAddressingMode  m_addressingModeV;
			ETextureAddressingMode  m_addressingModeW;
			ETextureCoordGen	    m_texCoordGenerationMode;
			
			//Static texture transformations
			Math::Vector3D	m_scroll;
			Math::Vector3D  m_scale;
			Float			m_rotate;

			//Animated texture transformations
			Math::Vector3D  m_scrollAnim;
			Math::Vector3D  m_scaleAnim;
			Float		    m_rotateAnim;


			//Used to store transformation state
			Float			m_wavePosition;
			Math::Matrix4x4 m_textureTransform;

			//Wave transformations
			std::vector<WaveXForm> m_waveTransforms;

	};
	//End class TextureUnit

	
    //=========================================================================
    //! @function    TextureUnit::SetColourOp
    //! @brief       Set the colour blending operation between a texture unit and its predecessors
    //!              
    //! @param       operation [in] Operation
    //! @param       arg1	   [in] First argument
    //! @param       arg2	   [in] Second argument
    //!              
    //=========================================================================
	void TextureUnit::SetColourOp ( ETextureOp operation, ETextureArgument arg1, ETextureArgument arg2 )
	{
		m_colourOp.operation = operation;
		m_colourOp.arg1 = arg1;
		m_colourOp.arg2 = arg2;
	}
	//End TextureUnit::SetColourOp


    //=========================================================================
    //! @function    TextureUnit::SetAlphaOp
    //! @brief       Set the alpha blending operation between a texture unit and its predecessors
    //!              
    //! @param       operation [in] Operation
    //! @param       arg1	   [in] First argument
    //! @param       arg2	   [in] Second argument
    //!              
    //=========================================================================
	void TextureUnit::SetAlphaOp ( ETextureOp operation, ETextureArgument arg1, ETextureArgument arg2 )
	{
		m_alphaOp.operation = operation;
		m_alphaOp.arg1 = arg1;
		m_alphaOp.arg2 = arg2;
	}
	//End TextureUnit::SetAlphaOp




    //=========================================================================
    //! @function    TextureUnit::AddressingMode
    //! @brief       Get the addressing mode for one of the texture coordinate components
    //!              
    //! @param       type [in] Coordinate component to get
    //!              
    //! @return      The addressing mode for the coordinate component specified by type
    //=========================================================================
	ETextureAddressingMode TextureUnit::AddressingMode ( ETextureAddressModeType type ) const
	{
		switch ( type )
		{
			case TEX_ADDRESS_U:
				return m_addressingModeU;

			case TEX_ADDRESS_V:
				return m_addressingModeV;

			case TEX_ADDRESS_W:
				return m_addressingModeW;

			default:
				debug_assert ( false, "Invalid addressing mode!" );
		}
	}
	//End TextureUnit::AddressingMode




    //=========================================================================
    //! @function    TextureUnit::SetAddressingMode
    //! @brief       Set the addressing mode for one of the texture coordinate components
    //!              
    //! @param       type			[in] Coordinate component to set the addressing mode for
    //! @param       addressingMode [in] Addressing mode to set
    //!              
    //=========================================================================
	void TextureUnit::SetAddressingMode ( ETextureAddressModeType type, ETextureAddressingMode addressingMode )
	{
		switch ( type )
		{
			case TEX_ADDRESS_U:
				m_addressingModeU = addressingMode;
				return;

			case TEX_ADDRESS_V:
				m_addressingModeV = addressingMode;
				return;

			case TEX_ADDRESS_W:
				m_addressingModeW = addressingMode;
				return;

			default:
				debug_assert ( false, "Invalid addressing mode!" );
		}
	}
	//End TextureUnit::SetAddressingMode



    //=========================================================================
    //! @function    TextureUnit::AddWaveTransform
    //! @brief       Add a wave transformation
    //!              
    //! @param       transformType 
    //! @param       waveType 
    //! @param       base 
    //! @param       frequency 
    //! @param       phase 
    //! @param       amplitude 
    //!        
    //=========================================================================
	void TextureUnit::AddWaveTransform ( EXFormType transformType, EWaveType waveType, Float base,
										 Float frequency, Float phase, Float amplitude )
	{
		WaveXForm transform;

		transform.transformType = transformType;
		transform.waveType = waveType;
		transform.base = base;
		transform.frequency = frequency;
		transform.phase = phase;
		transform.amplitude = amplitude;

		m_waveTransforms.push_back ( transform );
	}
	//End TextureUnit::AddWaveTransform



    //=========================================================================
    //! @function    TextureUnit::GetWaveTransform
    //! @brief       Get one of the wave transforms
    //!              
    //! @param       index [in] Index of the transformation, must be less than WaveTransformCount()
    //!              
    //! @return      
    //=========================================================================
	const TextureUnit::WaveXForm& TextureUnit::GetWaveTransform ( UInt index ) const
	{
		debug_assert ( index < m_waveTransforms.size(), "Transform index out of range!" );
		return m_waveTransforms[index];
	}
	//End TextureUnit::GetWaveTransform



};
//end namespace Renderer


#endif 
//#ifndef RENDERER_TEXTUREUNIT_H
